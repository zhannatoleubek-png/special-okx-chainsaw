# -*- coding: utf-8 -*-
"""Untitled24.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nEhEth8_mRLtWwNEgjoEe8QB6lHDm9Mf
"""

!pip install ta requests pandas numpy --quiet

import requests
import pandas as pd
import numpy as np
import time
from datetime import datetime
from ta.trend import SMAIndicator, EMAIndicator, MACD
from ta.momentum import RSIIndicator
from ta.volatility import AverageTrueRange

# -------------------------- ‚öôÔ∏è –ù–ê–°–¢–†–û–ô–ö–ò --------------------------
TELEGRAM_TOKEN = "8294892098:AAFX0Zzq9yN1on6UlID8f7vzif4dWR_7uWs"
CHAT_ID = 381202205

TELEGRAM_TOKEN = "8384092933:AAGLjBoqqukdZEWoV8_FZHRbQT6QOZOFAQo"
CHAT_ID = 343376986

BASE_URL = "https://www.okx.com/api/v5"
HEADERS = {"User-Agent": "Mozilla/5.0"}

INTERVALS = ["1m", "5m", "15m", "30m"]
VOLATILITY_THRESHOLD = 0.003
PAUSE_BETWEEN_COINS = 1.5
SLEEP_MINUTES = 10

last_signals = {}

# -------------------------- üì® TELEGRAM --------------------------
def send_telegram(message):
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
        payload = {"chat_id": CHAT_ID, "text": message, "parse_mode": "HTML"}
        requests.post(url, data=payload)
    except Exception as e:
        print("–û—à–∏–±–∫–∞ Telegram:", e)

# -------------------------- üìä –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –º–æ–Ω–µ—Ç --------------------------
def fetch_usdt_futures():
    try:
        r = requests.get(f"{BASE_URL}/public/instruments?instType=SWAP", headers=HEADERS).json()
        return [d["instId"] for d in r.get("data", []) if "USDT" in d["instId"]]
    except Exception as e:
        print("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ø–∏—Å–∫–∞:", e)
        return []

# -------------------------- üìà –ê–Ω–∞–ª–∏–∑ –æ–¥–Ω–æ–π –º–æ–Ω–µ—Ç—ã --------------------------
def analyze_symbol(symbol):
    scores = []
    for tf in INTERVALS:
        try:
            url = f"{BASE_URL}/market/candles?instId={symbol}&bar={tf}&limit=200"
            r = requests.get(url, headers=HEADERS, timeout=10).json()
            data = r.get("data", [])
            if not data:
                continue
            df = pd.DataFrame(data, columns=["ts","o","h","l","c","v","vCcy","vUsd","confirm"])
            df = df.astype({"o":float,"h":float,"l":float,"c":float,"v":float})
            df = df.iloc[::-1].reset_index(drop=True)
            if len(df) < 50:
                continue

            atr = AverageTrueRange(df["h"], df["l"], df["c"], window=14).average_true_range()
            volatility = atr.iloc[-1] / df["c"].iloc[-1]
            if volatility < VOLATILITY_THRESHOLD:
                return None

            sma = SMAIndicator(df["c"], 20).sma_indicator()
            ema = EMAIndicator(df["c"], 50).ema_indicator()
            macd = MACD(df["c"]).macd_diff()
            rsi = RSIIndicator(df["c"]).rsi()

            price = df["c"].iloc[-1]
            score = 0
            if sma.iloc[-1] > ema.iloc[-1]: score += 1
            if macd.iloc[-1] > 0: score += 1
            if rsi.iloc[-1] < 30: score += 1
            if sma.iloc[-1] < ema.iloc[-1]: score -= 1
            if macd.iloc[-1] < 0: score -= 1
            if rsi.iloc[-1] > 70: score -= 1
            scores.append(score)
        except Exception:
            continue

    if not scores:
        return None

    avg_signal = np.mean(scores)
    atr_val = atr.iloc[-1]
    if avg_signal >= 1.5:
        signal = "üü¢ –°–ò–õ–¨–ù–´–ô –õ–û–ù–ì"
        sl = price - 2 * atr_val
        tp = price + 3 * atr_val
    elif 0.5 <= avg_signal < 1.5:
        signal = "üü© –õ–û–ù–ì"
        sl = price - 1.5 * atr_val
        tp = price + 2.5 * atr_val
    elif -1.5 <= avg_signal <= -0.5:
        signal = "üü• –®–û–†–¢"
        sl = price + 1.5 * atr_val
        tp = price - 2.5 * atr_val
    elif avg_signal < -1.5:
        signal = "üî¥ –°–ò–õ–¨–ù–´–ô –®–û–†–¢"
        sl = price + 2 * atr_val
        tp = price - 3 * atr_val
    else:
        return None

    return {"symbol": symbol, "signal": signal, "price": round(price,4), "sl": round(sl,4), "tp": round(tp,4)}

# -------------------------- üîÅ –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª --------------------------
def run_bot():
    global last_signals
    print("üöÄ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä—ã–Ω–∫–∞ –∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç.")
    send_telegram("ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä—ã–Ω–∫–∞ –∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç.")

    symbols = fetch_usdt_futures()
    if not symbols:
        print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ñ—å—é—á–µ—Ä—Å–æ–≤.")
        return

    while True:
        start_time = datetime.utcnow().strftime("%H:%M:%S")
        print(f"\nüïì {start_time} ‚Äî –Ω–∞—á–∞–ª–æ –∞–Ω–∞–ª–∏–∑–∞ {len(symbols)} –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤")

        new_signals = []
        for i, sym in enumerate(symbols[:80]):  # –æ–≥—Ä–∞–Ω–∏—á–∏–º –¥–æ 80 –º–æ–Ω–µ—Ç
            print(f"[{i+1}/{len(symbols)}] {sym}", end="\r")
            result = analyze_symbol(sym)
            if not result:
                continue

            key = f"{result['symbol']}_{result['signal']}"
            if key != last_signals.get(result["symbol"]):
                new_signals.append(result)
                last_signals[result["symbol"]] = key

        if new_signals:
            msg = f"üìä <b>{len(new_signals)} –Ω–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤</b>:\n\n"
            for s in new_signals:
                msg += f"{s['symbol']}: {s['signal']}\n–¶–µ–Ω–∞: {s['price']}\nSL: {s['sl']}\nTP: {s['tp']}\n\n"
            send_telegram(msg)
            print(msg)
        else:
            print("üì≠ –ù–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –Ω–µ—Ç.")

        print(f"‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ {SLEEP_MINUTES} –º–∏–Ω...\n")
        for sec in range(SLEEP_MINUTES * 60):
            time.sleep(1)

# -------------------------- ‚ñ∂Ô∏è –ó–∞–ø—É—Å–∫ --------------------------
run_bot()
